{"ast":null,"code":"import { useEffect, useState } from \"react\";\nexport const useFetch = url => {\n  const [state, setState] = useState({\n    data: null,\n    loading: true\n  });\n  useEffect(() => {\n    setState(state => ({\n      data: state.data,\n      loading: true\n    })); //? Ici ont est obliger d'utiliser une IIFE(Immediately Invoked Function Expression)\n    //! C/ nous somme dans un useEffect Hooks.\n\n    (async () => {\n      let res = await fetch(url);\n      let value = await res.text();\n      setState({\n        data: value,\n        loading: false\n      });\n    })();\n  }, [url, setState]);\n  return state;\n}; // On aurai pu le faire avec des callbaks comme sa\n\n/*\nimport {useEffect, useState } from \"react\";\n\nexport const useFetch = url => {\nconst [state, setState] = useState({ data: null, loading: true});\n\nuseEffect(() => {\n    setState({data: null, loading: true});\n    fetch(url)\n    .then(x => x.text())\n    .then(y => {\n        setState({ data: y, loading: false });\n    });\n\n    }, [url]);\n\n    return state;\n}\n*/","map":{"version":3,"sources":["/home/user/Bureau/react-ben/ben-awad-hooks/use-memo/src/useFetch.jsx"],"names":["useEffect","useState","useFetch","url","state","setState","data","loading","res","fetch","value","text"],"mappings":"AAAA,SAAQA,SAAR,EAAmBC,QAAnB,QAAmC,OAAnC;AAEA,OAAO,MAAMC,QAAQ,GAAGC,GAAG,IAAI;AAC3B,QAAM,CAACC,KAAD,EAAQC,QAAR,IAAoBJ,QAAQ,CAAC;AAAEK,IAAAA,IAAI,EAAE,IAAR;AAAcC,IAAAA,OAAO,EAAE;AAAvB,GAAD,CAAlC;AACAP,EAAAA,SAAS,CAAC,MAAM;AACZK,IAAAA,QAAQ,CAACD,KAAK,KAAK;AAACE,MAAAA,IAAI,EAAGF,KAAK,CAACE,IAAd;AAAoBC,MAAAA,OAAO,EAAE;AAA7B,KAAL,CAAN,CAAR,CADY,CAEZ;AACA;;AACA,KAAC,YAAY;AACT,UAAIC,GAAG,GAAG,MAAMC,KAAK,CAACN,GAAD,CAArB;AACA,UAAIO,KAAK,GAAG,MAAMF,GAAG,CAACG,IAAJ,EAAlB;AACAN,MAAAA,QAAQ,CAAC;AAAEC,QAAAA,IAAI,EAAEI,KAAR;AAAeH,QAAAA,OAAO,EAAE;AAAxB,OAAD,CAAR;AACH,KAJD;AAKC,GATI,EASF,CAACJ,GAAD,EAAME,QAAN,CATE,CAAT;AAUA,SAAOD,KAAP;AACH,CAbM,C,CAgBP;;AAEA","sourcesContent":["import {useEffect, useState } from \"react\";\n\t\nexport const useFetch = url => {\n    const [state, setState] = useState({ data: null, loading: true});\n    useEffect(() => {\n        setState(state => ({data : state.data, loading: true}));\n        //? Ici ont est obliger d'utiliser une IIFE(Immediately Invoked Function Expression)\n        //! C/ nous somme dans un useEffect Hooks.\n        (async () => {\n            let res = await fetch(url);\n            let value = await res.text();\n            setState({ data: value, loading: false });\n        })();\n        }, [url, setState]);\n    return state;\n}\n\n\n// On aurai pu le faire avec des callbaks comme sa\n\n/*\nimport {useEffect, useState } from \"react\";\n\nexport const useFetch = url => {\nconst [state, setState] = useState({ data: null, loading: true});\n\nuseEffect(() => {\n    setState({data: null, loading: true});\n    fetch(url)\n    .then(x => x.text())\n    .then(y => {\n        setState({ data: y, loading: false });\n    });\n\n    }, [url]);\n\n    return state;\n}\n*/"]},"metadata":{},"sourceType":"module"}